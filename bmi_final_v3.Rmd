---
title: "bmi_final"
author: "Qianshu Wang"
date: "2017/12/9"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(DT)
library(xtable)
library(knitr)
library(readr)
library(tidyverse)
library(haven)
library(readxl)
library(janitor)
library(pander)
library(Hmisc)
library(multcomp)
library(reshape2)
library(faraway)
library(leaps)
library(HH)
library(broom)
library(GGally)
library(olsrr)
```

### 0. Description
Outcome: length of stay (losdays2 or loshour)

### 1. Clean Data
```{r read_data}
GHP_raw = read_excel("./GHProject_Dataset.xlsx") %>%
  clean_names() 
```

#####1. We may not need to remove ICU_flagged obs.
```{r clean ICU_Flag}
#histogram
# GHP_raw %>%
#   ggplot(aes(x = losdays2, color = icu_flag)) +
#     geom_bar(data = GHP_raw %>% filter(icu_flag == 0), aes(x = losdays2)) +
#     geom_bar(data = GHP_raw %>% filter(icu_flag == 1), aes(x = losdays2)) +
#     theme_bw()
#     
# GHP_raw %>%
#   ggplot(aes(y = losdays2, x = icu_flag, group = icu_flag)) +
#     geom_boxplot()

# 
# GHP = GHP_raw %>%
#   filter(ICU_Flag != 1)
```

#####2. change admitdtm into date formate, relevel cindex and mews based on project instruction, and keep the the first visit for each patient (70 observations were removed)
```{r change date format}
GHP = GHP_raw %>%
  separate(admitdtm, into = c("weekday", "date", "year"), sep = ",") %>% 
  mutate(date = paste(date, " 2016"), date = as.Date(date, format = " %B %d %Y")) %>%
  dplyr::select(-year) %>%
  mutate(cindex = if_else(cindex == 1 & cindex == 2, 1, cindex), 
         cindex = if_else(cindex == 3 & cindex == 4, 2, cindex), 
         cindex = if_else(cindex >= 5, 3, cindex)) %>% # 0 = normal, 1 = mild, 2 = moderate, 3 = severe
  mutate(mews = if_else(mews == 1, 0, mews), 
         mews = if_else((mews == 2) + (mews == 3) == 1, 1, mews), 
         mews = if_else((mews == 4) + (mews == 5) == 1, 2, mews), 
         mews = if_else(mews > 5, 3, mews)) %>% # 0 = normal, 1 = increase caution, 2 = further deterioration, 3 = immediate action required
  group_by(patientid) %>%
  filter(date == min(date)) %>%
  ungroup()
```

#####3. We wanted to investigate the relationship between the length of stay and the health/socioeconomics status of patients, so we decided the variables of intrest to exclude "postalcode", "facilityzip", "facilityname", "date", "weekday", "patientid", and "visitid". Because we also noticed that "loshours" and "losday2" are in fact the same variable with different unit, we chose to only use the "loshours". (why we choose vital signs over mews?)
```{r choose relavent variables}
GHP = GHP %>%
  dplyr::select(-postalcode, -facilityzip, -facilityname, -date, -weekday, -mews, -patientid, -visitid, -losdays2) #%>%
  #mutate(is30dayreadmit = as.factor(is30dayreadmit), icu_flag = as.factor(icu_flag), gender = as.factor(gender), race = as.factor(race), religion = as.factor(religion), maritalstatus = as.factor(maritalstatus), insurancetype = as.factor(insurancetype)) 
  
  # mutate(log_losdays2 = log(losdays2), log_o2sat = log(o2sat), log_resp = log(respirationrate), squre_resp = (respirationrate)^2,  log_bmi = log(bmi), squre_o2sat = (o2sat)^2, log_heart = log(heartrate))
```

#####4. Missing values were replaced with the median of that variable for numeric data. We choose median over mean to address potential skewness in variables.
```{r}
replace_na_w_median = function(vector){
  if (is.numeric(vector)) {
    vector[is.na(vector)] = median(vector, na.rm = TRUE)
  } else if (is.character(vector)) {
    vector[is.na(vector)] = "unknown"
  }
  return(vector)
}

GHP_missing_to_median = map_df(GHP, replace_na_w_median)
```



### 2. Exploratory analysis

#####1. We first examine the distribution of the outcome, "losdays2", with boxplot and histogram.
```{r}
attach(GHP_missing_to_median)
boxplot(loshours)
histogram(loshours)
```
we can see the distribution of the outcome is highly right skewed, so we performed log transformation to it, and the transformed outcome looks symmetrical. 
```{r}
attach(GHP_missing_to_median)
boxplot(log(loshours))
histogram(log(loshours))
GHP_missing_to_median = GHP_missing_to_median %>%
  mutate(log_los = log(loshours)) %>%
  dplyr::select(-loshours)
```
The boxplot suggests 51 outliers in outcome, and they were removed. 
```{r}
# attach(GHP_missing_to_median)
# lowerbound = quantile(log_los, probs = 0.25) - 1.5 * IQR(log_los)
# upperbound = quantile(log_los, probs = 0.75) + 1.5 * IQR(log_los)
# GHP_missing_to_median = GHP_missing_to_median %>%
#   filter(log_los < upperbound, log_los > lowerbound)
# boxplot(log_los)
# histogram(log_los)
```

#####2. We use "ggpairs" to investigate the distribution of each variable and check whether they have potential association. (this may goes to the appendix)
```{r ggpairs, message=FALSE, warning=FALSE, fig.height=30, fig.width= 30}
#ggpairs(GHP_missing_to_median) + ggplot2::theme_bw()
# attach(GHP)
# boxplot(bpsystolic)
# boxplot(bpdiastolic)
# boxplot(o2sat)
# boxplot(temperature)
# boxplot(heartrate)
# boxplot(respirationrate)
# boxplot(bmi)
# boxplot(ageyear)
# boxplot(cindex)
# # 
# histogram(bpsystolic)
# histogram(bpdiastolic)
# histogram(o2sat)
# histogram(temperature)
# histogram(heartrate)
# histogram(respirationrate)
# histogram(bmi)
# histogram(ageyear)
# histogram(cindex)
# histogram(evisit)
# histogram(icu_flag)
# ggplot(data = GHP_missing_to_median, aes(x = religion)) + geom_bar()
# ggplot(data = GHP_missing_to_median, aes(x = maritalstatus)) + geom_bar()
# ggplot(data = GHP_missing_to_median, aes(x = race)) + geom_bar()
# ggplot(data = GHP_missing_to_median, aes(x = insurancetype)) + geom_bar()
# ggplot(data = GHP_missing_to_median, aes(x = gender)) + geom_bar()
```


### 3. model building

anova tests for categorical data: all categorical variable shows significant difference among their levels, except gender. However, I still include gender in the full model, because ref...?.
```{r anova for each categorical data}
# slr_gender = lm(log_los ~ gender, data = GHP_missing_to_median)
# slr_maritalstatus = lm(log_los ~ maritalstatus, data = GHP_missing_to_median)
# slr_insurancetype = lm(log_los ~ insurancetype, data = GHP_missing_to_median)
# slr_religion = lm(log_los ~ religion, data = GHP_missing_to_median)
# anova(slr_gender)
# anova(slr_maritalstatus)
# anova(slr_insurancetype)
# anova(slr_religion)
```

what is the boxplot of marital status
```{r}
# GHP_missing_to_median %>%
#   ggplot(aes(x = maritalstatus, y = log_los)) +
#     geom_boxplot()
```
We noticed that there is only one civial union, so we decided to combine this observation into married
```{r}
GHP_missing_to_median = GHP_missing_to_median %>%
  mutate(maritalstatus = if_else(maritalstatus == "Civil Union", "Married", maritalstatus))
```




##### 1. The full model is
```{r full model}
# fit all predictor:
mult.reg = lm(log_los ~ bmi + o2sat + heartrate + bpsystolic + bpdiastolic + respirationrate + temperature + is30dayreadmit + cindex + evisit + ageyear + gender + race + religion + maritalstatus + insurancetype, data = GHP_missing_to_median)
  summary(mult.reg)
```
##### 2. Auto
1. stepwise
```{r}
stepwise <- step(mult.reg, direction = 'both')
summary(stepwise)
```
2. forward
```{r}
fwd <- step(mult.reg, direction = 'forward')
summary(fwd)
```
3. backward
```{r}
bwd <- step(mult.reg, direction = 'backward')
summary(bwd)
```

```{r}
# auto_reduce1 <- update(stepwise, . ~ . -maritalstatus)
# summary(auto_reduce1)
```

```{r}
# auto_reduce2 <- update(auto_reduce1, . ~ . -o2sat)
# summary(auto_reduce2)
```
6. reduced model, without o2sat
```{r}
auto_reduce3 <- update(stepwise, . ~ . -o2sat)
summary(auto_reduce3)
```

7. Anova test for nested models
```{r}
# anova(auto_reduce1, stepwise)
# anova(auto_reduce2, stepwise)
anova(auto_reduce3, stepwise) # show this
```

So, it suggests that o2sat can be removed. Thus, the model from the auto method is :
```{r}
auto_model = auto_reduce3
summary(auto_model)
```


##### 3. Criterion based model selection
Calculate the criterion for each model size.
```{r}
best <- function(model, ...) 
{
  subsets <- regsubsets(formula(model), model.frame(model), nvmax = 19, ...)
  subsets <- with(summary(subsets),
                  cbind(p = as.numeric(rownames(which)), which, rss, rsq, adjr2, cp, bic))
  
  return(subsets)
}  

best_subsets = best(mult.reg, nbest = 1)
pander(best_subsets)


par(mar=c(4,4,1,1))
par(mfrow=c(1,2))

plot(1:19, best_subsets[, "cp"], xlab="No. of predictor", ylab="Cp Statistic")
abline(0,1)

plot(1:19, best_subsets[, "adjr2"], xlab="No. of predictor", ylab="Adj R2")
```

1. The selected criterion-based model is
```{r}
crit = lm(log_los ~ o2sat + heartrate + bpsystolic + bpdiastolic + respirationrate + temperature + is30dayreadmit + cindex + evisit + ageyear + gender + religion + maritalstatus + insurancetype, data = GHP_missing_to_median)
  summary(crit)
```
However, there are still several unsignificant predictors, so I tried to remove them from the model.

2. reduced model without o2sat
```{r}
crit_reduce1 = update(crit, . ~ . -o2sat)
summary(crit_reduce1)
```

3. reduced model without religion
```{r}
crit_reduce2 = update(crit, . ~ . -religion)
summary(crit_reduce2)
```

4. reduced model without maritalstatus
```{r}
crit_reduce3 = update(crit, . ~ . -maritalstatus)
summary(crit_reduce3)
```

5. reduce model without o2sat and religion and maritalstatus and 
```{r}
crit_reduce4 = update(crit_reduce1, . ~ . -religion)
crit_reduce5 = update(crit_reduce4, . ~ . -maritalstatus)
summary(crit_reduce5)
```

6. Use anova to test these reduced models vs. the full model
```{r}
anova(crit_reduce1, crit)
anova(crit_reduce2, crit)
anova(crit_reduce3, crit)
anova(crit_reduce5, crit) #show this
```

Thus, the full model is not superior to crit_reduce5, based on the principle of parsimony, we choose the crit_reduce5
```{r}
criterion_based_model = crit_reduce5
summary(criterion_based_model)
```

##### 4. THe final model
Since the criterion-based model and the automatic selected model are the same, we have the final model shown as below:
```{r}
final_model = criterion_based_model
summary(final_model)
write_csv(broom::tidy(final_model), "model estimate.csv")
```

##### 5. check interaction
```{r}
# final_model_interaction = lm(log_los ~ heartrate * bpsystolic * bpdiastolic * respirationrate * temperature * is30dayreadmit * cindex * evisit * ageyear * gender * maritalstatus * insurancetype, data = GHP_missing_to_median)
# summary(final_model_interaction)
```





### 4. Model diagnostic and remedie
#####1. check collinearity NO significant collinearity, using the VIF cut-off at 10
```{r}
pander(vif(final_model))
```

#####2. diagnostic plots
```{r}
par(mfrow = c(2, 2))
plot(final_model)
```

#####3. detect and remove outliers
```{r}
#detect outliers
stu_res<-rstandard(final_model)
outliers_y<-stu_res[abs(stu_res)>2.5]
outliers_y

#remove outliers
#rm_list_outlier = as.numeric(names(outliers_y))
rm_list_outlier = c(65, 75)
wholelist = 1:nrow(GHP_missing_to_median)
keep_list_outlier <- wholelist[!wholelist %in% rm_list_outlier]

GHP_outliers = GHP_missing_to_median[rm_list_outlier, ]
GHP_missing_to_median_clean = GHP_missing_to_median[keep_list_outlier, ]
```


#####4. detect and remove influential points and leverage points
```{r}
#as.data.frame(influence.measures(final_model))

inf = influence.measures(final_model)
#which(apply(inf$is.inf, 1, any))
#summary(inf)

#remove outliers
#rm_list_influential = unique(which(apply(inf$is.inf, 1, any)))
rm_list_influential = c(47, 54, 75, 55, 65, 51, 66, 46, 60, 53)
wholelist_influential = 1:nrow(GHP_missing_to_median_clean)
keep_list_influential <- wholelist_influential[!wholelist_influential %in% rm_list_influential]

GHP_influential=GHP_missing_to_median[rm_list_influential, ]
GHP_missing_to_median_clean = GHP_missing_to_median_clean[keep_list_influential, ]
```

#####5. 
Fit the final model without outliers, influential points, and leverage points
```{r}
final_model_clean = lm(log_los ~ heartrate + bpsystolic + bpdiastolic + respirationrate + temperature + is30dayreadmit + cindex + evisit + ageyear + gender + insurancetype, data = GHP_missing_to_median_clean)
summary(final_model_clean)
write_csv(broom::tidy(summary(final_model_clean)), "clean model estimate.csv")
```

The diagnostic of this model
```{r}
par(mfrow = c(2, 2))
plot(final_model_clean)
```
fit a new model with new data
```{r}
mult.reg_1 = lm(log_los ~ bmi + o2sat + heartrate + bpsystolic + bpdiastolic + respirationrate + temperature + is30dayreadmit + cindex + evisit + ageyear + gender + race + religion + maritalstatus + insurancetype, data = GHP_missing_to_median_clean)
  summary(mult.reg_1)
```

1. stepwise
```{r}
stepwise_1 <- step(mult.reg_1, direction = 'both')
summary(stepwise_1)
```
criterion
```{r}
best <- function(model, ...) 
{
  subsets <- regsubsets(formula(model), model.frame(model), nvmax = 18, ...)
  subsets <- with(summary(subsets),
                  cbind(p = as.numeric(rownames(which)), which, rss, rsq, adjr2, cp, bic))
  
  return(subsets)
}  

best_subsets_1 = best(mult.reg_1, nbest = 1)
pander(best_subsets_1)


par(mar=c(4,4,1,1))
par(mfrow=c(1,2))

plot(1:18, best_subsets_1[, "cp"], xlab="No. of predictor", ylab="Cp Statistic")
abline(0,1)

plot(1:18, best_subsets_1[, "adjr2"], xlab="No. of predictor", ylab="Adj R2")
```

### 5. Model validation